'use strict';
var through = require('through2'),
    juicer  = require('juicer'),
    fs = require('fs'),
    path = require('path'),
    Buffer = require('buffer').Buffer;

var method_body = [
    "var __escapehtml = {",
    "escapehash: {",
    "'<': '&lt;',",
    "'>': '&gt;',",
    "'&': '&amp;',",
    "'\"': '&quot;',",
    "\"'\": '&#x27;',",
    "'/': '&#x2f;'",
    "},",
    "escapereplace: function(k) {",
    "return __escapehtml.escapehash[k];",
    "},",
    "escaping: function(str) {",
    "return typeof(str) !== 'string' ? str : str.replace(/[&<>\"]/igm, this.escapereplace);",
    "},",
    "detection: function(data) {",
    "return typeof(data) === 'undefined' ? '' : data;",
    "}",
    "};",

    "var __throw = function(error) {",
    "if(typeof(console) !== 'undefined') {",
    "if(console.warn) {",
    "console.warn(error);",
    "return;",
    "}",

    "if(console.log) {",
    "console.log(error);",
    "return;",
    "}",
    "}",

    "throw(error);",
    "};",

    "_method = _method || juicer.options._method;",
    "_method.__escapehtml = __escapehtml;",
    "_method.__throw = __throw;"
].join('');

module.exports = function(argv){

    return through.obj(function(file, encoding, callback){

        if (file.isNull()) {
            this.push(file);
            return callback();
        }

        if (file.isStream()) {
            return callback(uglifyError('Streaming not supported'));
        }


        argv = argv || {};
        // Convert the known list into a hash

        var known = {};

        if (argv.known && !Array.isArray(argv.known)) {
            argv.known = [argv.known];
        }

        if (argv.known) {
            for (var i = 0, len = argv.known.length; i < len; i++) {
                known[argv.known[i]] = true;
            }
        }

        var output = [];

        if (!argv.simple) {
            if (argv.amd) {
                output.push('define([\'' + argv.juicerPath + 'juicer\'], function(juicer) {\n');
            } else {
                output.push('(function() {\n');
            }

            if(argv.namespace) {
                output.push('  var templates = ' + argv.namespace + ';\n');
            } else {
                output.push('  var template = juicer.template, templates = juicer.templates = juicer.templates || {};\n');
            }
        }

        function processTemplate(file) {

            var content = String(file.contents);;

            var options = {
                knownHelpers: known,
                knownHelpersOnly: argv.o
            };

            var result = juicer.compile(content, options)._render.toString().replace(/^function anonymous[^{]*?{([\s\S]*?)}$/igm, function($, fn_body) {
                return 'function(_, _method) {' + method_body + fn_body + '}';
            });

            if (argv.simple) {
                output.push(result + '\n');
            } else {
                output.push('templates[\'' + path.basename(file.path) + '\'] = ' + result + ';\n');
            }
        }

        try{
            processTemplate(file);

            // Output the content
            if (!argv.simple) {
                if (argv.amd) {
                    output.push('});');
                } else {
                    output.push('})();');
                }
            }
            output = output.join('');

            file.contents = new Buffer(output);

            if(argv.fnMap){
                file.path = file.path.replace.apply(file.path, argv.fnMap);
                fs.writeFileSync(file.path, file.contents);
            }

            this.push(file);
            callback();
        }catch(e){
            console.warn('Error caught from gulp-juicer: ' + e.message + ' in ' + file.path + '.');
            this.push(file);
            return callback();
        }
    });
}